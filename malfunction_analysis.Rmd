---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.1
  kernelspec:
    display_name: Python [conda env:.conda-rsp] *
    language: python
    name: conda-env-.conda-rsp-py
---

```{python}
# %autosave 0
# %matplotlib notebook
# %matplotlib qt4
# %load_ext autoreload
# %autoreload 2
import sys
sys.path.append("./flatland_ckua")

from rsp.utils.experiments import EXPERIMENT_DATA_SUBDIRECTORY_NAME
from rsp.utils.experiments import load_and_expand_experiment_results_from_data_folder
from rsp.compute_time_analysis.compute_time_analysis import trajectories_from_resource_occupations_per_agent
from rsp.compute_time_analysis.compute_time_analysis import extract_schedule_plotting
from rsp.compute_time_analysis.compute_time_analysis import plot_time_resource_trajectories
from rsp.compute_time_analysis.compute_time_analysis import plot_resource_time_diagrams
from rsp.compute_time_analysis.compute_time_analysis import get_difference_in_time_space_trajectories
from rsp.compute_time_analysis.compute_time_analysis import plot_delay_propagation_2d
from rsp.compute_time_analysis.compute_time_analysis import plot_histogram_from_delay_data


from rsp.hypothesis_two_encounter_graph import compute_disturbance_propagation_graph
from rsp.hypothesis_two_encounter_graph import resource_occpuation_from_transmission_chains
from rsp.hypothesis_two_encounter_graph import plot_delay_propagation_graph

```

### Load Experiment Data

```{python}
experiment_base_directory = '../rsp-data/agent_0_malfunction_2020_06_04T19_17_28/'
experiment_of_interest = 0
```

Extract data and aggregate plotting data

```{python}
experiment_data_directory = f'{experiment_base_directory}/{EXPERIMENT_DATA_SUBDIRECTORY_NAME}'

exp_results_of_experiment_of_interest = load_and_expand_experiment_results_from_data_folder(
    experiment_data_folder_name=experiment_data_directory,
    experiment_ids=[experiment_of_interest],
    nonify_problem_and_results=False
)[0]
plotting_data = extract_schedule_plotting(experiment_result=exp_results_of_experiment_of_interest)
```

### Analyze Experiment Data

Compute the propagation wave from the malfunction with no re-scheduling. We compute how the malfunction would propagate in the schedule if no re-scheduling actions are taken. This means that between two consecutive trains on the same resource, the delay propagates if their temporal distance is smaller than the duration of the delay. The delay passed on to the next consists of the difference between the duration of the delay and the time between trains.

```{python}
transmission_chains, distance_matrix, weights_matrix, minimal_depth = compute_disturbance_propagation_graph(schedule_plotting=plotting_data)
changed_trajectories, changed_agents_dict = get_difference_in_time_space_trajectories(
                        base_trajectories=schedule_trajectories,
                        target_trajectories=reschedule_trajectories)
true_positives = resource_occpuation_from_transmission_chains(transmission_chains,changed_agents_dict)
unchanged_agents = {}
for agent in changed_agents_dict:
    unchanged_agents[agent] = not changed_agents_dict[agent]
false_positives = resource_occpuation_from_transmission_chains(transmission_chains,unchanged_agents)
true_positives_trajectories = trajectories_from_resource_occupations_per_agent(true_positives,plotting_data.plotting_information)
false_positives_trajectories = trajectories_from_resource_occupations_per_agent(false_positives,plotting_data.plotting_information)

```

Get resource occupation and time-space trajectories for initial schedule

```{python}
schedule_resource_occupations = plotting_data.schedule_as_resource_occupations.sorted_resource_occupations_per_agent
schedule_trajectories = trajectories_from_resource_occupations_per_agent(schedule_resource_occupations
                                                                         ,plotting_data.plotting_information)
```

Get resource occupation and time-space trajectories for delta reschedule

```{python}
reschedule_resource_occupations = plotting_data.reschedule_delta_as_resource_occupations.sorted_resource_occupations_per_agent
reschedule_trajectories = trajectories_from_resource_occupations_per_agent(reschedule_resource_occupations,
                                                                           plotting_data.plotting_information)
```

### Malfunction spread without interventions from re-scheduling algorithm

Visualize the propagation of the malfunction in the schedule. Only forward propagation is considered and no re-scheduling is assumed. This illustrates the extent of the malfunction if no actions are taken.

```{python}
plot_time_resource_trajectories(title="Malfunction Propagation in Schedule",
                                trajectories=schedule_trajectories,
                                ranges=plotting_data.plotting_information.dimensions,
                                malfunction=plotting_data.malfunction,
                                true_positives_wave=true_positives_trajectories,
                                false_positives_wave=false_positives_trajectories)
```

Spatially the influence of the malfunction would have spread according to the following plot

```{python}
plot_delay_propagation_2d(plotting_data=plotting_data,
                          delay_information=exp_results_of_experiment_of_interest.lateness_delta_after_malfunction,
                          depth_dict=minimal_depth)
```

### Re-scheduling to prevent spread of malfunction

Given the actions of the re-scheduling algorithm, the spread can be limited both in time and space. The figures below show the actual spread after the malfunction when actions were taken to stay close to the initial schedule

```{python}
plot_time_resource_trajectories(title="Influenced Trains after re-scheduling",
                                trajectories=changed_trajectories,
                                ranges=plotting_data.plotting_information.dimensions,
                                malfunction=plotting_data.malfunction)
```

The spatial spread of the malfunction can be seen below. The arrows indicate direction of travel, the thickness of the arrow indicates the total delay of an agent. The colors show the depth of influence from the initial agent, meaning if it was directly or indirectly influenced.

```{python}
plot_delay_propagation_2d(plotting_data=plotting_data,
                          delay_information=exp_results_of_experiment_of_interest.lateness_delta_after_malfunction,
                          depth_dict=minimal_depth,
                          changed_agents=changed_agents_dict)
```

Figure below shows the histogram of the delay times, giving us a great overview of how strongly trains where affected by the malfunciton

```{python}
plot_histogram_from_delay_data(experiment_results=exp_results_of_experiment_of_interest)
```

```{python}

```
