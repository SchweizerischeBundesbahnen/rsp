"""Tools and Methods to analyse the data generated by the experiments.

Methods
-------
average_over_trials
    Average over all the experiment trials
"""
import os
from typing import List
from typing import Optional
from typing import Tuple

import matplotlib
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from flatland.envs.rail_trainrun_data_structures import TrainrunDict
from matplotlib import axes
from mpl_toolkits.mplot3d import Axes3D
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from pandas import DataFrame
from pandas import Series

from rsp.route_dag.route_dag import ScheduleProblemDescription
from rsp.utils.data_types import COLUMNS_ANALYSIS, ExperimentResultsAnalysis
from rsp.utils.data_types import convert_experiment_results_analysis_to_data_frame
from rsp.utils.data_types import convert_pandas_series_experiment_results
from rsp.utils.data_types import expand_experiment_results_for_analysis
from rsp.utils.data_types import ExperimentResults

from flatland.core.grid.grid_utils import coordinate_to_position

# workaround: WORKSPACE is defined in ci where we do not have Qt installed

if 'WORKSPACE' not in os.environ:
    matplotlib.use('Qt5Agg')
# Dummy import currently because otherwise the import is removed all the time but used by 3d scatter plot
axes3d = Axes3D


# https://stackoverflow.com/questions/25649429/how-to-swap-two-dataframe-columns
def swap_columns(df: DataFrame, c1: int, c2: int):
    """Swap columns in a data frame.

    Parameters
    ----------
    df: DataFrame
        The data frame.
    c1: int
        the column index
    c2: int
        the other column index.
    """
    df['temp'] = df[c1]
    df[c1] = df[c2]
    df[c2] = df['temp']
    df.drop(columns=['temp'], inplace=True)


def average_over_trials(experimental_data: DataFrame) -> Tuple[DataFrame, DataFrame]:
    """
    Average over all the experiment trials
    Parameters
    ----------
    experimental_data

    Returns
    -------
    DataFrame of mean data and DataFram of standard deviations
    """

    averaged_data = experimental_data.groupby(['experiment_id']).mean().reset_index()
    standard_deviation_data = experimental_data.groupby(['experiment_id']).std().reset_index()
    return averaged_data, standard_deviation_data


def three_dimensional_scatter_plot(data: DataFrame,
                                   columns: DataFrame.columns,
                                   error: DataFrame = None,
                                   file_name: str = "",
                                   fig: Optional[matplotlib.figure.Figure] = None,
                                   subplot_pos: str = '111',
                                   subplot_title: str = '',
                                   colors: Optional[List[str]] = None):
    """Adds a 3d-scatterplot as a subplot to a figure.

    Parameters
    ----------
    data: DataFrame
        DataFrame containing data to be plotted
    error: DataFrame
        DataFrame containing error of z values to plot
    columns: DataFrame.columns
        Three columns of that data frame to be plotted against each other, x_values, y_values,z_values
    file_name: string
        If provided the plot is stored to figure instead of shown
    fig: Optional[matplotlib.figure.Figure]
        If given, adds the subplot to this figure without showing it, else creates a new one and shows it.
    subplot_pos: str
        a 3-digit integer describing the position of the subplot.
    colors: List[str]
        List of colors for the data points.

    Returns
    -------
    """
    x_values = data[columns[0]].values
    y_values = data[columns[1]].values
    z_values = data[columns[2]].values
    experiment_ids = data['experiment_id'].values

    show = False
    if fig is None:
        show = True
        fig = plt.figure()

    ax: axes.Axes = fig.add_subplot(subplot_pos, projection='3d')
    ax.set_xlabel(columns[0])
    ax.set_ylabel(columns[1])
    ax.set_zlabel(columns[2])
    if not subplot_title:
        ax.set_title(str(columns))
    else:
        ax.set_title(subplot_title)

    ax.scatter(x_values, y_values, z_values, color=colors)
    for i in np.arange(0, len(z_values)):
        ax.text(x_values[i], y_values[i], z_values[i], "{}".format(experiment_ids[i]))

    if error is not None:
        # plot errorbars
        z_error = error[columns[2]].values
        for i in np.arange(0, len(z_values)):
            ax.plot([x_values[i], x_values[i]], [y_values[i], y_values[i]],
                    [z_values[i] + z_error[i], z_values[i] - z_error[i]], marker="_")

    if len(file_name) > 1:
        plt.savefig(file_name)
    elif show:
        plt.show()


def two_dimensional_scatter_plot(data: DataFrame,
                                 columns: DataFrame.columns,
                                 error: DataFrame = None,
                                 baseline: DataFrame = None,
                                 link_column: str = 'size',
                                 file_name: Optional[str] = None,
                                 output_folder: Optional[str] = None,
                                 fig: Optional[matplotlib.figure.Figure] = None,
                                 subplot_pos: str = '111',
                                 title: str = None,
                                 colors: Optional[List[str]] = None,
                                 xscale: Optional[str] = None,
                                 yscale: Optional[str] = None
                                 ):
    """Adds a 2d-scatterplot as a subplot to a figure.

    Parameters
    ----------
    data: DataFrame
        DataFrame containing data to be plotted
    error: DataFrame
        DataFrame containing error of z values to plot
    columns: DataFrame.columns
        Three columns of that data frame to be plotted against each other, x_values, y_values,z_values
    file_name: string
        If provided the plot is stored to figure instead of shown
    fig: Optional[matplotlib.figure.Figure]
        If given, adds the subplot to this figure without showing it, else creates a new one and shows it.
    subplot_pos: str
        a 3-digit integer describing the position of the subplot.
    colors: List[str]
        List of colors for the data points.
    link_column: str
        Group data points by this column and draw a bar between consecutive data points.
    baseline
        data points that define a baseline. Visualized by a bar
    output_folder
        Save plot to this folder.
    title
        Plot title
    xscale
        Passed to matplotlib. See there for possible values such as 'log'.
    yscale
        Passed to matplotlib. See there for possible values such as 'log'.

    Returns
    -------
    """
    x_values: Series = data[columns[0]].values
    y_values: Series = data[columns[1]].values
    experiment_ids = data['experiment_id'].values

    if fig is None:
        fig = plt.figure()
        fig.set_size_inches(w=15, h=15)

    ax: axes.Axes = fig.add_subplot(subplot_pos)
    if title:
        ax.set_title(title)
    ax.set_xlabel(columns[0])
    ax.set_ylabel(columns[1])
    if xscale:
        ax.set_xscale(xscale)
    if yscale:
        ax.set_yscale(yscale)

    ax.scatter(x_values, y_values, color=colors)
    _2d_plot_label_scatterpoints(ax, experiment_ids, x_values, y_values)
    if error is not None:
        _2d_plot_errorbars(ax, columns, error, x_values, y_values)
    if baseline is not None:
        _2d_plot_baseline(ax, baseline, x_values, y_values)

    if link_column is not None:
        _2d_plot_link_column(ax, columns, data, link_column)

    if file_name is not None:
        plt.savefig(file_name)
    elif output_folder is not None:
        plt.savefig(os.path.join(output_folder, 'experiment_agenda_analysis_' + '_'.join(columns) + '.png'))


def _2d_plot_label_scatterpoints(ax: axes.Axes, experiment_ids: Series, x_values: Series, y_values: Series):
    """Add experiment id to data points."""
    for i in np.arange(0, len(y_values)):
        ax.text(x_values[i], y_values[i], "{}".format(experiment_ids[i]))


def _2d_plot_link_column(ax: axes.Axes, columns: DataFrame.columns, data: DataFrame, link_column: str):
    """Group data by a column and draw a line between consecutive data points
    of that group.

    It is assumed that the group has consecutive experiment ids!
    """
    grouped_data = data.groupby([link_column])
    cmap = plt.get_cmap("tab10")
    group_index = 0
    for _, group in grouped_data:
        sorted_group = group.sort_values('experiment_id')
        # index is experiment_id! Therefore, count the number of iterations
        count = 0
        for index, _ in sorted_group.iterrows():
            count += 1
            if count >= len(sorted_group):
                break
            ax.plot([sorted_group.at[index, columns[0]], sorted_group.at[index + 1, columns[0]]],
                    [sorted_group.at[index, columns[1]], sorted_group.at[index + 1, columns[1]]],
                    marker="_",
                    color=cmap(group_index))
        group_index += 1


def _2d_plot_errorbars(ax: axes.Axes, columns: DataFrame.columns, error: DataFrame, x_values: Series, y_values: Series):
    """Plot error range."""
    y_error = error[columns[1]].values
    for i in np.arange(0, len(y_values)):
        ax.plot([x_values[i], x_values[i]],
                [y_values[i] + y_error[i], y_values[i] - y_error[i]], marker="_")


def _2d_plot_baseline(ax: axes.Axes, baseline: DataFrame, x_values: Series, y_values: Series):
    """Plot baseline y values and draw a line to the data points."""
    for i in np.arange(0, len(y_values)):
        ax.plot([x_values[i], x_values[i]],
                [baseline[i], y_values[i]], marker="_")


def expand_experiment_data_for_analysis(
        experiment_data: DataFrame, debug: bool = False
) -> DataFrame:
    """Derive additional fields from the computed results without.

    Do it here for the following reasons:
    1. no need to re-run the experiments for new derived properties;
    2. re-run new analysis logic on existing experiment data
    3. keep experiment logic as simple as possible
    """
    data = []

    for _, row in experiment_data.iterrows():
        experiment_results: ExperimentResults = convert_pandas_series_experiment_results(row)
        experiment_id = experiment_results.experiment_parameters.experiment_id

        expanded_experiment_results = expand_experiment_results_for_analysis(
            experiment_results=experiment_results,
            experiment_id=experiment_id,
            debug=debug
        )
        data.append(convert_experiment_results_analysis_to_data_frame(
            experiment_results=expanded_experiment_results
        ))

    data_frame = pd.DataFrame(columns=COLUMNS_ANALYSIS, data=data)
    for key in ['speed_up',
                'size',
                'n_agents',
                'max_num_cities',
                'max_rail_between_cities',
                'max_rail_in_city',
                'nb_resource_conflicts_full',
                'nb_resource_conflicts_full_after_malfunction',
                'nb_resource_conflicts_delta_after_malfunction',
                'path_search_space_schedule',
                'path_search_space_rsp_full', 'path_search_space_rsp_delta',
                'factor_path_search_space', 'size_used',
                'time_full',
                'time_full_after_malfunction',
                'time_delta_after_malfunction',
                ]:
        print(key)
        print(data_frame[key])
        data_frame[key] = data_frame[key].astype(float)
    return data_frame


def visualize_agent_density(experiment_data: ExperimentResultsAnalysis, output_folder: str):
    """
    Method to visualize the density of agents in the full schedule.

    Parameters
    ----------
    rows : ExperimentResultsAnalysis
    output_folder

    Returns
    -------

    """
    train_runs_input: TrainrunDict = experiment_data.solution_full
    problem_description: ScheduleProblemDescription = experiment_data.problem_full
    max_episode_steps = problem_description.max_episode_steps
    agent_density = np.zeros(max_episode_steps)

    for train_run in train_runs_input:
        start_time = train_runs_input[train_run][0][0]
        end_time = train_runs_input[train_run][-1][0]
        agent_density[start_time:end_time + 1] += 1

    fig = plt.figure()
    fig.set_size_inches(w=15, h=15)
    ax: plt.axes.Axes = fig.add_subplot(111)
    ax.set_title('Agent density during schedule')
    ax.set_xlabel('Time')
    ax.set_ylabel('Nr. active Agents')
    plt.plot(agent_density)
    plt.savefig(os.path.join(output_folder, 'experiment_agenda_analysis_agent_density.png'))


def weg_zeit_diagramm(experiment_data: ExperimentResultsAnalysis, three_dimensional: bool, volumetric: bool = False):
    schedule = experiment_data.solution_full
    reschedule = experiment_data.solution_full_after_malfunction
    max_episode_steps = experiment_data.problem_full.max_episode_steps

    width = experiment_data.experiment_parameters.width
    height = experiment_data.experiment_parameters.height

    if not three_dimensional:
        weg_zeit_matrize_schedule, sorting = weg_zeit_matrix_from_schedule(schedule=schedule, width=width,
                                                                           height=height,
                                                                           max_episode_steps=max_episode_steps,
                                                                           sorting=None)
        weg_zeit_matrize_reschedule, _ = weg_zeit_matrix_from_schedule(schedule=reschedule, width=width, height=height,
                                                                       max_episode_steps=max_episode_steps,
                                                                       sorting=sorting)
        fig = plt.figure()
        ax: plt.axes.Axes = fig.add_subplot(111)
        ax.set_title('Time-Ressource-Diagram')
        ax.set_xlabel('Ressource')
        ax.set_ylabel('Time')
        plt.matshow(np.transpose(weg_zeit_matrize_schedule), cmap='gist_ncar')
        plt.matshow(np.transpose(weg_zeit_matrize_reschedule), cmap='gist_ncar')
        plt.show()
    else:
        fig = plt.figure()
        ax = fig.gca(projection='3d')
        ax.set_title('Time-Ressource-Diagram 3D')
        ax.set_xlabel('x')
        ax.set_ylabel('y')
        ax.set_zlabel('Time')
        if volumetric:
            voxels = weg_zeit_3d_voxels(schedule=schedule, width=width, height=height,
                                        max_episode_steps=max_episode_steps)
            ax.voxels(voxels)
            plt.show()
        else:
            train_time_paths = weg_zeit_3d_path(schedule=reschedule)
            for train_path in train_time_paths:
                x, y, z = zip(*train_path)
                ax.plot(x, y, z, linewidth=2)
            plt.show()


def weg_zeit_matrix_from_schedule(schedule, width, height, max_episode_steps, sorting=None):
    weg_zeit_matrize = np.zeros(shape=(width * height, max_episode_steps))
    if sorting is None:
        sorting = []
    for train_run in schedule:
        pre_waypoint = schedule[train_run][0]
        for waypoint in schedule[train_run][1:]:
            pre_time = pre_waypoint.scheduled_at
            time = waypoint.scheduled_at
            position = coordinate_to_position(width, [pre_waypoint.waypoint.position])  # or is it height?
            weg_zeit_matrize[position, pre_time:time] += train_run
            pre_waypoint = waypoint
            if position not in sorting:
                sorting.append(position)
    weg_zeit_matrize = weg_zeit_matrize[sorting][:, 0, :]
    return weg_zeit_matrize, sorting


def weg_zeit_3d_path(schedule):
    all_train_time_paths = []
    for train_run in schedule:
        train_time_path = []
        pre_waypoint = schedule[train_run][0]
        for waypoint in schedule[train_run][1:]:
            time_pre = pre_waypoint.scheduled_at
            (x_pre, y_pre) = pre_waypoint.waypoint.position
            time = waypoint.scheduled_at
            train_time_path.append((x_pre, y_pre, time_pre))
            train_time_path.append((x_pre, y_pre, time))
            pre_waypoint = waypoint
        all_train_time_paths.append(train_time_path)
    return all_train_time_paths


def weg_zeit_3d_voxels(schedule, width, height, max_episode_steps):
    voxels = np.zeros(shape=(width, height, max_episode_steps), dtype=int)
    for train_run in schedule:
        pre_waypoint = schedule[train_run][0]
        for waypoint in schedule[train_run][1:]:
            pre_time = pre_waypoint.scheduled_at
            time = waypoint.scheduled_at
            (x, y) = pre_waypoint.waypoint.position
            voxels[x, y, pre_time:time] = 1
            pre_waypoint = waypoint
    return voxels
