---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.1
  kernelspec:
    display_name: Python [conda env:.conda-rsp] *
    language: python
    name: conda-env-.conda-rsp-py
---

```{python}
# %autosave 0
# %matplotlib notebook
# %matplotlib qt4
# %load_ext autoreload
# %autoreload 2
import sys
sys.path.append("./flatland_ckua")
```

```{python}
import pandas as pd
from IPython.display import Video

from rsp.utils.data_types import convert_list_of_experiment_results_analysis_to_data_frame, convert_pandas_series_experiment_results_analysis
from rsp.utils.experiments import EXPERIMENT_DATA_SUBDIRECTORY_NAME
from rsp.utils.experiments import load_and_expand_experiment_results_from_data_folder
from rsp.compute_time_analysis.compute_time_analysis import plot_computational_times
from rsp.compute_time_analysis.compute_time_analysis import plot_histogram_from_delay_data
from rsp.compute_time_analysis.compute_time_analysis import plot_many_time_resource_diagrams
from rsp.compute_time_analysis.compute_time_analysis import plot_speed_up
from rsp.compute_time_analysis.compute_time_analysis import render_flatland_env
from rsp.compute_time_analysis.compute_time_analysis import plot_route_dag
from rsp.route_dag.route_dag import ScheduleProblemEnum
```

```{python}

experiment_base_directory = './res/exp_hypothesis_one_2020_03_31T07_11_03/'

experiments_of_interest = None
```

```{python}
experiment_data_directory = f'{experiment_base_directory}/{EXPERIMENT_DATA_SUBDIRECTORY_NAME}'
experiment_results_list = load_and_expand_experiment_results_from_data_folder(experiment_data_folder_name=experiment_data_directory,experiment_ids=experiments_of_interest)
experiment_data: pd.DataFrame = convert_list_of_experiment_results_analysis_to_data_frame(experiment_results_list)
```

```{python}
import pandas as pd
data_frame = pd.DataFrame(data=[
    {
'experiment_id': r.experiment_id,
'grid_id': r.grid_id,
'size': r.size,
'n_agents': r.n_agents,
'max_num_cities': r.max_num_cities,
'max_rail_between_cities': r.max_rail_between_cities,
'max_rail_in_city': r.max_rail_in_city,
'time_full': r.time_full,
'time_full_after_malfunction': r.time_full_after_malfunction,
'time_delta_after_malfunction': r.time_delta_after_malfunction,
'costs_full': r.costs_full,
'costs_full_after_malfunction': r.costs_full_after_malfunction,
'costs_delta_after_malfunction': r.costs_delta_after_malfunction,
'nb_resource_conflicts_full': r.nb_resource_conflicts_full,
'nb_resource_conflicts_full_after_malfunction': r.nb_resource_conflicts_full_after_malfunction,
'nb_resource_conflicts_delta_after_malfunction': r.nb_resource_conflicts_delta_after_malfunction,
'speed_up': r.speed_up,
'factor_resource_conflicts': r.factor_resource_conflicts,
'path_search_space_schedule': r.path_search_space_schedule,
'path_search_space_rsp_full': r.path_search_space_rsp_full,
'path_search_space_rsp_delta': r.path_search_space_rsp_delta,
'factor_path_search_space': r.factor_path_search_space,
'size_used': r.size_used,
'solver_conflicts_full': r.results_full.solver_statistics["solving"]["solvers"]["conflicts"],
'solver_choices_full': r.results_full.solver_statistics["solving"]["solvers"]["choices"],
'solver_conflicts_full_after_malfunction': r.results_full_after_malfunction.solver_statistics["solving"]["solvers"]["conflicts"],
'solver_choices_full_after_malfunction': r.results_full_after_malfunction.solver_statistics["solving"]["solvers"]["choices"],
'solver_conflicts_delta_after_malfunction': r.results_delta_after_malfunction.solver_statistics["solving"]["solvers"]["conflicts"],
'solver_choices_delta_after_malfunction': r.results_delta_after_malfunction.solver_statistics["solving"]["solvers"]["choices"],

    }
    for r in experiment_results_list])
data_frame.to_csv(f"data.tsv", sep="\t")
# display(data_frame)
```

```{python}
axis_of_interest = 'n_agents'
columns_of_interest = ['time_full','time_full_after_malfunction','time_delta_after_malfunction']
```

### Visualize Compuational time comparison

```{python}
from rsp.hypothesis_one_data_analysis import hypothesis_one_analysis_visualize_computational_time_comparison
hypothesis_one_analysis_visualize_computational_time_comparison(experiment_data=experiment_data)

# for exploration, use:
# plot_computational_times(experiment_data=experiment_data,
#                                   axis_of_interest=axis_of_interest,
#                                   columns_of_interest=columns_of_interest)
```

### Visualize Speed Up factors for experiments

```{python}
from rsp.hypothesis_one_data_analysis import hypothesis_one_analysis_visualize_speed_up
hypothesis_one_analysis_visualize_speed_up(experiment_data=experiment_data)

# for exploration, use:
# plot_speed_up(experiment_data=experiment_data,
#                        axis_of_interest=axis_of_interest)
```

## Find interesting experiments with route alternatives in Delta

```{python}
for experiment in experiment_results_list:
#     print(experiment.experiment_id)
    for agent_id, topo in experiment.problem_delta_after_malfunction.topo_dict.items():
         for node, in_degree in topo.in_degree:
                if in_degree > 1 and agent_id != experiment.malfunction.agent_id:
                     print(f"experiment_id={experiment.experiment_id}, agent_id={agent_id}, node={node}, in_degree={in_degree}")


```

### Visualize Weg-Zeit-Diagram of specific experiment

```{python}
experiment_of_interest = 79
```

```{python}
single_experiment_dataframe = experiment_data.loc[experiment_data['experiment_id'] == experiment_of_interest].iloc[0]
single_exp_results = convert_pandas_series_experiment_results_analysis(single_experiment_dataframe)
choices_full_schedule = single_exp_results.results_full.solver_statistics["solving"]["solvers"]["choices"]
choices_full_reschedule = single_exp_results.results_full_after_malfunction.solver_statistics["solving"]["solvers"]["choices"]
choices_delta_reschedule = single_exp_results.results_delta_after_malfunction.solver_statistics["solving"]["solvers"]["choices"]
```

```{python}
experiment_details = experiment_data.loc[experiment_data['experiment_id'] == experiment_of_interest,['experiment_id','malfunction','size',
       'n_agents', 'max_num_cities', 'max_rail_between_cities',
       'max_rail_in_city', 'time_full', 'time_full_after_malfunction',
       'time_delta_after_malfunction','speed_up','nb_resource_conflicts_full',
       'nb_resource_conflicts_full_after_malfunction',
       'nb_resource_conflicts_delta_after_malfunction']]
experiment_details['choices_full_schedule'] = choices_full_schedule
experiment_details['choices_full_reschedule'] = choices_full_reschedule
experiment_details['choices_delta_reschedule'] = choices_delta_reschedule

```

```{python}
display(experiment_details.transpose())
```

```{python}
#list(filter(lambda s: s.startswith('shared'), single_exp_results.results_full_after_malfunction.solver_result))
```

```{python}
changed_agents = plot_many_time_resource_diagrams(experiment_data_frame=experiment_data,experiment_id = experiment_of_interest, with_diff=True)
```

#### Histogram of delay per agent after re-scheduling

```{python}
plot_histogram_from_delay_data(experiment_data_frame=experiment_data,experiment_id = experiment_of_interest)
```

#### Render the current environment

```{python}
video_src_schedule, video_src_reschedule=render_flatland_env(data_folder=experiment_base_directory ,experiment_data_frame=experiment_data,experiment_id = experiment_of_interest)
```

```{python}
Video(video_src_schedule, embed=True)
```

```{python}
Video(video_src_reschedule, embed=True)
```

#### Route DAGs for individual agents

```{python}
agent_of_interest = 30
```

```{python}
# %matplotlib inline
plot_route_dag(single_exp_results,agent_of_interest, ScheduleProblemEnum.PROBLEM_SCHEDULE)
```

```{python}
# %matplotlib inline
plot_route_dag(single_exp_results,agent_of_interest, ScheduleProblemEnum.PROBLEM_RSP_FULL)
```

```{python}
# %matplotlib inline
plot_route_dag(single_exp_results,agent_of_interest, ScheduleProblemEnum.PROBLEM_RSP_DELTA)
```

#### Encounter Graphs

```{python}
import numpy as np
from rsp.encounter_graph.encounter_graph import UndirectedEncounterGraphDistance
def undirected_temporal_distance_between_trains(train_schedule_0, train_run_0,train_schedule_1,train_run_1):

    # get positions in time window
    #train_0_positions = [waypoint.position for i, waypoint in train_schedule_0.items()]
    #train_1_positions = [waypoint.position for i, waypoint in train_schedule_1.items()]
    time_distance = 0. #np.inf
    visited_waypoints = []
    for time_0, waypoint_0 in train_schedule_0.items():
        resource_distance = 0.
        for time_1, waypoint_1 in train_schedule_1.items():
            if waypoint_0 is not None and waypoint_1 is not None:
                if waypoint_0.position == waypoint_1.position:
                    tmp_distance =  0.5* 1./np.abs(time_1-time_0)
                    if waypoint_0.position in visited_waypoints:
                        if tmp_distance > resource_distance:
                            resource_distance = tmp_distance
                    else:
                        visited_waypoints.append(waypoint_0.position)
        time_distance += resource_distance


    distance = UndirectedEncounterGraphDistance(inverted_distance=(time_distance),
                                                time_of_min=(time_0),
                                                train_0_position_at_min=train_schedule_0[time_0],
                                                train_1_position_at_min=train_schedule_1[time_1])

    return distance
```

```{python}
from rsp.encounter_graph.encounter_graph_visualization import plot_encounter_graphs_for_experiment_result
predicted_agents = plot_encounter_graphs_for_experiment_result(experiment_result=single_exp_results,highlighted_nodes=changed_agents,metric_function=undirected_temporal_distance_between_trains)
```

```{python}
for idx, agent in changed_agents.items():
    if agent:
        if idx in predicted_agents:
            sys.stdout.write("\033[0;32m")
            print("Agent {} changed and was predicted.".format(idx))
        else:
            sys.stdout.write("\033[1;31m")
            print("Agent {} was missed.".format(idx))

```

```{python}
for agent in predicted_agents:
    if changed_agents[agent]:
        sys.stdout.write("\033[0;32m")
        print("Agent {} was predicted and changed.".format(agent))
    else:
        sys.stdout.write("\033[1;31m")
        print("Agent {} was falsely predicted.".format(agent))
```

### Visualize Hypothesis 009 Do rescheduling  times grow exponentially in the number of time window overlaps?

```{python}
from rsp.hypothesis_one_data_analysis import visualize_hypothesis_009_rescheduling_times_grow_exponentially_in_the_number_of_time_window_overlaps
visualize_hypothesis_009_rescheduling_times_grow_exponentially_in_the_number_of_time_window_overlaps(experiment_results_list=experiment_results_list)

```

```{python}
from rsp.hypothesis_one_data_analysis import visualize_hypotheses_asp
visualize_hypotheses_asp(experiment_results_list=experiment_results_list)

```

```{python}

```

```{python}

```
