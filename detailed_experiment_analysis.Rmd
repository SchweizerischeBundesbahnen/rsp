---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.1
  kernelspec:
    display_name: Python [conda env:.conda-rsp] *
    language: python
    name: conda-env-.conda-rsp-py
---

```{python}
# %autosave 0
# %load_ext autoreload
# %autoreload 2
import sys
sys.path.append("./flatland_ckua")
import pandas as pd
from IPython.display import Video

from rsp.utils.data_types import convert_list_of_experiment_results_analysis_to_data_frame, convert_pandas_series_experiment_results_analysis

from rsp.utils.experiments import EXPERIMENT_DATA_SUBDIRECTORY_NAME
from rsp.utils.experiments import load_and_expand_experiment_results_from_data_folder

from rsp.compute_time_analysis.compute_time_analysis import render_flatland_env
from rsp.compute_time_analysis.compute_time_analysis import plot_route_dag
from rsp.compute_time_analysis.compute_time_analysis import plot_schedule_metrics
from rsp.compute_time_analysis.compute_time_analysis import plot_time_window_resource_trajectories
from rsp.compute_time_analysis.compute_time_analysis import plot_shared_heatmap
from rsp.compute_time_analysis.compute_time_analysis import extract_schedule_plotting
from rsp.compute_time_analysis.compute_time_analysis import time_windows_as_resource_occupations_per_agent
from rsp.compute_time_analysis.compute_time_analysis import trajectories_from_resource_occupations_per_agent
from rsp.compute_time_analysis.compute_time_analysis import plot_time_resource_trajectories
from rsp.compute_time_analysis.compute_time_analysis import plot_time_density
from rsp.compute_time_analysis.compute_time_analysis import plot_resource_occupation_heat_map

from rsp.schedule_problem_description.data_types_and_utils import ScheduleProblemEnum
```

```{python}
experiment_base_directory = '../rsp-data/agent_0_malfunction_2020_06_04T19_17_28/'
experiment_of_interest = 0
```

```{python}
experiment_data_directory = f'{experiment_base_directory}/{EXPERIMENT_DATA_SUBDIRECTORY_NAME}'

single_exp_results = load_and_expand_experiment_results_from_data_folder(
    experiment_data_folder_name=experiment_data_directory,
    experiment_ids=[experiment_of_interest],
    nonify_problem_and_results=False
)[0]
plotting_data = extract_schedule_plotting(experiment_result=single_exp_results)
```

### Visualize Problem instances as time-resource graphs
This visualization shows the parameter spaced available to the optimizer to find solutions. Initial schedule is not shown as we have a tabularasa approach with no restrictions. Full rescheduling has the following available parameter space

```{python}
resource_occupations_reschedule = time_windows_as_resource_occupations_per_agent(problem=single_exp_results.problem_full_after_malfunction)
trajectories = trajectories_from_resource_occupations_per_agent(
    resource_occupations_schedule=resource_occupations_reschedule,
    plotting_information=plotting_data.plotting_information)
choices_full_reschedule = single_exp_results.results_full_after_malfunction.solver_statistics["solving"]["solvers"]["choices"]
print("Number of choices the solver has to make was {}".format(choices_full_reschedule))
plot_time_resource_trajectories(trajectories=trajectories,
                                title="Full Reschedule Problem",
                                ranges=plotting_data.plotting_information.dimensions,
                                malfunction=plotting_data.malfunction)

```

Using the perfect oracle we can reduce the available parameters to disjunct patches in the space-time-continuum ;)

```{python}
resource_occupations_delta_reschedule = time_windows_as_resource_occupations_per_agent(problem=single_exp_results.problem_delta_after_malfunction)
trajectories = trajectories_from_resource_occupations_per_agent(
    resource_occupations_schedule=resource_occupations_delta_reschedule,
    plotting_information=plotting_data.plotting_information)
choices_delta_reschedule = single_exp_results.results_delta_after_malfunction.solver_statistics["solving"]["solvers"]["choices"]
print("Number of choices the solver has to make was {}".format(choices_delta_reschedule))
plot_time_resource_trajectories(trajectories=trajectories,
                                title="Delta Reschedule Problem",
                                ranges=plotting_data.plotting_information.dimensions,
                                malfunction=plotting_data.malfunction)
```

### Some metrics about the schedule


Number of agents at each time step for the initial schedule

```{python}
plot_time_density(plotting_data.schedule_as_resource_occupations)
```

```{python}
plot_resource_occupation_heat_map(
    schedule_as_resource_occupations=plotting_data.schedule_as_resource_occupations,
    plotting_information=plotting_data.plotting_information,
    title_suffix='Schedule'
)
```

#### Histogram of delay per agent after re-scheduling

```{python}
single_exp_results._fields
```

#### Render the current environment

```{python}
video_src_schedule, video_src_reschedule=render_flatland_env(data_folder=experiment_base_directory ,experiment_data_frame=experiment_data,experiment_id = experiment_of_interest)
```

```{python}
Video(video_src_schedule, embed=True)
```

```{python}
Video(video_src_reschedule, embed=True)
```

## Find interesting experiments with route alternatives in Delta

```{python}
for experiment in experiment_results_list:
#     print(experiment.experiment_id)
    for agent_id, topo in experiment.problem_delta_after_malfunction.topo_dict.items():
         for node, in_degree in topo.in_degree:
                if in_degree > 1 and agent_id != experiment.malfunction.agent_id:
                     print(f"experiment_id={experiment.experiment_id}, agent_id={agent_id}, node={node}, in_degree={in_degree}")
```

#### Route DAGs for individual agents

```{python}
# %matplotlib inline
agent_of_interest = 0
plot_route_dag(single_exp_results,agent_of_interest, ScheduleProblemEnum.PROBLEM_SCHEDULE)
```

```{python}
# %matplotlib inline
plot_route_dag(single_exp_results,agent_of_interest, ScheduleProblemEnum.PROBLEM_RSP_FULL)
```

```{python}
# %matplotlib inline
plot_route_dag(single_exp_results,agent_of_interest, ScheduleProblemEnum.PROBLEM_RSP_DELTA)
```

#### Time Resource Window Graph: time windows in scheduling problem per resource

```{python}
plot_time_window_resource_trajectories(experiment_result=single_exp_results,plotting_information=schedule_plotting.plotting_information)
```

#### Resource Heat Map: how many potential resource conflicts on this resource?

```{python}
plot_shared_heatmap(experiment_result=single_exp_results)
```

### Disturbance Propagation Graphs


```{python}
from rsp.hypothesis_two_encounter_graph import compute_disturbance_propagation_graph
```

```{python}
transmission_chains, distance_matrix, weights_matrix, minimal_depth = compute_disturbance_propagation_graph(experiment_result=single_exp_results)
```

### Visualize Hypothesis 009 Do rescheduling  times grow exponentially in the number of time window overlaps?

```{python}
from rsp.hypothesis_one_data_analysis import visualize_hypothesis_009_rescheduling_times_grow_exponentially_in_the_number_of_time_window_overlaps
visualize_hypothesis_009_rescheduling_times_grow_exponentially_in_the_number_of_time_window_overlaps(experiment_results_list=experiment_results_list)

```

```{python}
from rsp.hypothesis_one_data_analysis import visualize_hypotheses_asp
visualize_hypotheses_asp(experiment_results_list=experiment_results_list)

```
